



组件化：将一个App分成多个模块，每个模块都是一个组件（module），
开发过程中可以让这些组件相互依赖或独立编译、调试部分组件，
但是这些组件最终会合并成一个完整的Apk去发布到应用市场。

插件化：将整个app拆分成若干模块，其中有1个宿主模块、若干插件模块 。
宿主模块和插件模块可以分开进行编译，二者之间互不影响，各个模块可以并发进行开发

现在项目架构上都是组件化的框架，某些修改频繁的Module模块设置成插件模块，
编译成独立的APK文件，以插件的形式进行部署，供宿主模块调用。



插件化：
插件可以理解为免安装的apk，而支持插件的app称为宿主。

Android系统在打开应用之后，只是开辟进程，
然后使用ClassLoader加载classes.dex至进程中，执行对应的组件而已。

好处：
①减少安装Apk的体积、按需下载模块
②动态更新插件
③宿主和插件分开编译，提升开发效率

插件化和热修复不是同一个概念，虽然在技术实现的角度来说，
它们都是从系统加载器的角度出发，
通过“欺骗”Android系统的方式来让宿主正常的加载和运行插件/补丁中的内容，
但是它们的出发点是不同的。

插件化原理：
其实 Android 系统在打开应用之后，也只是开始进程，
然后使用ClassLoader加载 classes.dex 至进程中，执行对应的组件而已;
那大家可能会想一个问题，既然 Android 本身也是使用类似反射的形式加载代码执行，
凭什么我们不能执行一个 Apk 中的代码呢?

最显而易见的优势其实就是通过网络热更新、热修复;

双亲委派机制：
ClassLoader在加载类时，先查看自身是否已经加载过该类，如果没有加载过会首先让父加载器去加载，
如果父加载器无法加载该类时，该类才会调用自身的findClass方法去加载

https://blog.csdn.net/qq_36390114/article/details/121334799
互相调用：
插件调用主工程
在构造插件的ClassLoader时会传入主工程的ClassLoader作为父加载器，
所以插件可以直接通过类名引用主工程的类。
主工程调用插件：
若使用多classLoader机制，主工程引用插件的类需要先通过插件的ClassLoader加载该类，
再通过反射调用其方法，插件化框架一般会通过统一的入口去管理对各个插件中类的访问，并且做一定限制。




组件化的优势：
https://blog.csdn.net/zenmela2011/article/details/126032989
①各个组件专注自身功能的实现，模块中代码高度聚合，
只负责一项任务，也就是常说的单一职责原则；
②各组件高度解耦，各业务研发可以互不干扰、提升协作效率；
③加快编译速度，提高开发效率

组件化原理：
1.统一Gradle的版本号。每个模块都是一个application，
所以每个模块都会有一个build.gradle，各个模块里面的配置不同，因此需要重新统一Gradle。
2.创建基础库
3.每一个模块都有一个AndroidManifest的切换

ARouter实现组件之间的跳转
组件化有一个限制，就是禁止横向依赖，也就是说在同一层级下的多个模块是禁止相互依赖的。
这样做是为了解耦，最常用的就是ARouter框架。

ARouter实现跳转的原理是在ARouter内部维护了一个路由表，
路由表里的数据来自于各个模块的页面信息，每个模块负责向路由框架中注册自己的信息，
这样需要页面跳转的时候只需要输入要跳转的页面信息，
路由框架就会从路由表中去寻址找到该页面，然后就可以使用startActivity来跳转了。



https://blog.csdn.net/zenmela2011/article/details/126304850
https://blog.csdn.net/zenmela2011/article/details/126032989
https://blog.csdn.net/hailong0529/article/details/89392064
https://zhanghuayang.blog.csdn.net/article/details/55213884









