



一、事务：
是将一组读写操作组合在一起形成一个逻辑单元。
这些操作要么全部执行成功提交(commit)，
要么全部中止失败(abort,rollback），不会留下一个中间状态的烂摊子。

acid
原子性：事务是最小的执行单位，不允许分割。
一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，
持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，
即使数据库发生故障也不应该对其有任何影响。

隔离级别：
(读取未提交)(读取已提交)(可重复读)(可串行化)

事物传播机制：7种
https://www.cnblogs.com/liftsail/p/16639142.html
REQUIRED
NOT_SUPPORTED
NEVER






二、锁机制：
概念:
1.当一个事务正在使用一张表时，数据库会给这个表加一把锁
2.另一个事务不能操作

锁的类型
颗粒度：行锁，表锁，页锁
行锁<页锁<表锁
行锁：开销大，加锁慢，会出现死锁。发生锁冲突的概率最低。

使用的方式 ：共享锁，排它锁
共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，
但任何事务都不能对数据进行修改。
排他锁：其他人不能操作。

思想：乐观锁，悲观锁
乐观锁：先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。
（适用于多读的应用类型，这样可以提高吞吐量。）
悲观锁：先获取锁，再进行业务操作，一般就是利用类似 SELECT
… FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。
（传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等）

死锁：
1.死锁是指两个或多个事务在同一资源上相互占用
2.解决死锁思路，一般就是切断环路，尽量避免并发形成环路。
3.如何避免
3.1.如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会；
3.2.尽可能做到一次锁定所需要的所有资源
3.3对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度







