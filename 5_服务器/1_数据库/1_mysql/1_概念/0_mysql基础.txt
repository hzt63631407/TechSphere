



数据库：本质就是一个软件管理系统
（增删改查）
关系型数据库：简单来说，就是一个二维表格
性能：一般的 MySQL，扛到每秒 2k 个请求就差不多了


数据库分层
1.网络接口层
2.服务层，sql接口：解析
3.内存数据层
4.磁盘数据


视图
概念：是从一个或几个基本表（或视图）导出的表，它与基本表不同，是一个虚表。
视图的建立和删除不影响基本表。
视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。
使用场景/好处：
查询简单化：简化复杂的SQL操作。
安全性：保护数据


约束：
是为了保证数据的完整性，在字段后面进行约束（创建）
约束可能是列级或表级。列级约束仅应用于一列，表级约束应用于整个表。

非空约束：not null;
唯一约束：unique();
主键约束：primary key();

mysql> create table t_user(
    -> id int(10),
    -> name varchar(32) not null,
    -> email varchar(128) unique
    -> );
Query OK, 0 rows affected (0.03 sec)




主键：
创建时：create table sc (
studentno int,
courseid int,
score int,
primary key (studentno) );
primary key用来唯一的约束字段里面的数据，不能重复，不能为空，
一张表中最多只能有一个主键，而且主键所在的列通常是整数类型。

外键：
foreign key(sno)
外键首先是表的一个字段，可以不是本表的主键，但要对应另外一个表的主键。



表结构：
三大范式：
第一范式：每个列都不可以再拆分。
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。
比如性能。事实上我们经常会为了性能而妥协数据库的设计。

主键和外键是两种类型的约束。
主键（约束）：主键是数据库确保数据行在整张表唯一性的保障
外建（约束）：用来在两个表的数据之间建立连接，可以指定一个字段或者多个字段为外键。
唯一（约束）：表的唯一一个字段

表分区
1.是指根据一定规则，将数据库中的一张表分解成多个更小的容易管理的部分。
从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。
2.好处：
2.1.存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。
2.2优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；



事务：
是将一组读写操作组合在一起形成一个逻辑单元。
这些操作要么全部执行成功提交(commit)，
要么全部中止失败(abort,rollback），不会留下一个中间状态的烂摊子。

acid
原子性：事务是最小的执行单位，不允许分割。
一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，
持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，
即使数据库发生故障也不应该对其有任何影响。

隔离级别：
(读取未提交)(读取已提交)(可重复读)(可串行化)

事物传播机制：7种
https://www.cnblogs.com/liftsail/p/16639142.html
REQUIRED
NOT_SUPPORTED
NEVER



锁机制：
概念:
1.当一个事务正在使用一张表时，数据库会给这个表加一把锁
2.另一个事务不能操作

锁的类型
颗粒度：行锁，表锁，页锁
行锁<页锁<表锁
行锁：开销大，加锁慢，会出现死锁。发生锁冲突的概率最低。

使用的方式 ：共享锁，排它锁
共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，
但任何事务都不能对数据进行修改。
排他锁：其他人不能操作。

思想：乐观锁，悲观锁
乐观锁：先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。
（适用于多读的应用类型，这样可以提高吞吐量。）
悲观锁：先获取锁，再进行业务操作，一般就是利用类似 SELECT
… FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。
（传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等）

死锁：
1.死锁是指两个或多个事务在同一资源上相互占用
2.解决死锁思路，一般就是切断环路，尽量避免并发形成环路。
3.如何避免
3.1.如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会；
3.2.尽可能做到一次锁定所需要的所有资源
3.3对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度



char于varchar的区别
char是固定长度，所以它的处理速度比varchar的速度要快，缺点是浪费存储空间。
所以，对存储不大但在速度上有要求的可以使用char类型，反之，使用varchar。




https://www.cnblogs.com/15078480385zyc/p/16465971.html
https://zhuanlan.zhihu.com/p/519775732
https://blog.csdn.net/qq_36756682/article/details/123738990
https://blog.csdn.net/hahazz233/article/details/125372412




