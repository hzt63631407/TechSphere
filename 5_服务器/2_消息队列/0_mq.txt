
基础介绍
1.mq本质来和数据库也是类似的，都是数据存/取
2.mq消息队列服务（是一个服务）特点是针对数据更改场景。
3.mq是数据临时中转地，新增+删除+少量的查询功能


如何使用
1.python，java有rocketmq库，可以用来连接mq
2.这个库有生产者（producer）消费（consumer）的方法

主题topic：某一类存放的标记，类似数据库里的表

mq是针对数据更改场景，redis是查询。

后端不直接写入数据库
生产者，接受前端来的数据,发送到mq
消费者，从mq把数据操作到数据库


mq快的原因：
mq的大部分数据都是在磁盘
mq服务比数据库操作快的原因：是因为没有约束，没有索引，不去校验表
最重要的高能原因：mq操作是顺序读写为主，数据库是随机读写磁盘。
（数据库有查询功能，所以是随机的）



类型：
1、Kafka 提供了超一流的读写性能,日志处理 数据缓冲 系统解耦
2、RabbitMQ 非常重量级，更适合于企业级的开发 负载均衡或者数据持久化
3、ActiveMQ 轻量级 中小型企业 性能较差



使用场景（优点）
应用场景：跨数据传递，日志分析，用户行为分析

1.应用解藕
难点：
A 系统发送数据到 BCD 三个系统，通过接口调用发送。
如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？
解决：
如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，
哪个系统需要数据自己去 MQ 里面消费。
如果新系统需要数据，直接从 MQ 里消费即可；

2.异步处理
难点：
A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库。
解决：
如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，
耗时 5ms，BCD再从数据库里取
（如果前端的功能调用的是异步接口，那么？如何确定接口实际操作完成了，
会配套异步查询。例如：双11，提交支付，【已提交，确认中】）


3.流量削峰
难点：
前端大量的请求，直接到数据库
解决：
前端请求传过来，要提交数据，先到mq，再到mysql
mq服务比数据库操作快的原因：是因为没有约束，没有索引，不去校验表


缺点
系统可用性降低：
你加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃。
系统复杂度变高：
怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
一致性问题：
要是 BCD 三个系统那里，BD 两个系统写库成功了，
结果 C 系统写库失败了，咋整？你这数据就不一致了。


消息模式
点对点模式（1个消息只能消费1次）
发布订阅模式（1个消息可以被多个消费者消费）


测试重点（不是很全）
异步时间：
1.存储到mysql时间长，时间是否可以接受
2.幂等性（推送同一条消息）：检查是否重复处理（业务上的唯一id，订单号）
3.消息在过程中是否丢失，传输的可靠性（如何发消息的）
3.1生产者弄丢了数据，开启mq的事务处理，如果没有接收到数据，就重发
3.2RabbitMQ弄丢了数据，开启 RabbitMQ 的持久化
3.3消费者弄丟了数据，进程挂了，进行ack处理
4.消息堆积，mq堆积的消息太多
4.1扩容


mq架构测试注意事项：
1.异步性   点完外卖，评论送积分，积分可以异步处理
2.消息丢失
发消息3种：
sync 同步发送  有重试 最慢
async 异步发送  有2次重试 代码执行后，不等待，有回调函数来接受
往往程序设计，要在接受mq确认没有问题之后，才继续进行。
one-way 只发一次 比较容易出问题 一般用于日志

p.sync 一定发送成功了，mq一定有数据
p.async 发送了，就继续执行下一步代码，但是mq不一定有数据，可能mq内存满了

mq刷盘（存入到mysql）
1.同步刷新（写入磁盘）
2.异步处理（写入到内存，定时写入磁盘）

3.幂等性：一次处理对应一次结果，不能重复处理
消费者代码-收到消息之后，要检查是否重复处理
业务上的唯一id，支付id，订单号




瓶颈分析
1.服务器资源不够用，cpu，内存，网络不够用
2.mq本身资源，java语言，堆内存
3.积压，消息是否积压，消费者处理能力


性能调优
使用调优和参数调优，参考官方文档
如：消费速度慢，加机器，加并行进程
如：jvm调优



mq：
1.消息队列，对数据写入，redis是读，mq是写
（和redis类似，是一个软件，需要用第三方进行连接，然后发送或者消费）
2.前端的请求把消息先写到mq，然后再写到mysql
3.消息队列的作用：
https://blog.csdn.net/weixin_52797128/article/details/125888104

3.1应用解藕，更加稳定，分成两步，一步是处理前端请求，一步写入到mysql

3.2异步处理，提高响应速度。
应用场景：网站用户注册，将注册信息写入数据库成功后，发送注册邮件和注册短信.
写到数据库（生产者），发送到mq，然后（注册邮件，注册短信）消费者来进行处理。

3.3削峰处理，mq尽快的处理请求，然后再慢慢写入到mysql
应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。
为解决这个问题，一般需要在应用前端加入消息队列。
可以控制活动的人数；可以缓解短时间内高流量压垮应用；

https://zhuanlan.zhihu.com/p/385564213


