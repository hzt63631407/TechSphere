
jvm的内存是固定的嘛？会不会有jvm满了，电脑的内存没有满，tps会出现瓶颈？
有默认值，会出现。jvm5g-6g 80%


1.jvm组成：
堆，(虚拟机)栈，本地方法栈，方法区，程序计数器

堆：堆中主要存储的是实际创建的对象，
也就是会存储通过new关键字创建的对象，堆中的对象能够被多个线程共享。

堆分为：
新生代和老生代，1：2
新生代分为：1个Eden区和2个Survivor区，8 : 1 : 1，伊甸园空间和幸存者空间。
新创建的User对象是存放在JVM堆空间中年轻代的Eden区
(当新生代内存不够时，老年代分配担保。而大对象则是直接在老年代分配。)

伊甸园空间- 所有新对象都被放入伊甸园空间。当伊甸园空间填满时，
垃圾收集运行并删除所有没有引用的对象。所有仍然有引用的对象都被提升到幸存者空间

幸存者空间- 如果不再引用对象，则在新生部分运行的每个垃圾收集都会从幸存者空间中删除对象。
如果该对象仍被引用，它将增加该对象的年龄。
在增量达到一定数量后，通常从 15 开始，具体取决于 JVM 实现，该对象将被提升到老年代部分。

一次完整的垃圾回收机制：当 Eden 区的空间满了，
Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，
存活下来的对象，则会转移到 Survivor区。每熬过一次Minor GC，年龄+1，
若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，
Full GC 清理整个内存堆 – 包括年轻代和老年代老年代。


栈（又叫作线程栈或虚拟机栈）：
一般存储的是局部变量。
所有的基本数据类型(byte、short、int、long、float、double、boolean、char)
和引用变量(对象引用)都是在栈中的。一般情况下，
线程退出或者方法退出时，栈中的数据会被自动清除。


本地方法栈：跟虚拟机栈类型，在用于调用操作系统的底层方法时才会创建栈帧。


程序计数器PC：
程序计数器也叫作PC计数器，只要存储的是下一条将要执行的命令的地址。


方法区(元空间)：
在程序中声明的常量、静态变量和有关于类的信息等的引用，都会存放在方法区。


说一下堆栈的区别？
功能方面：堆是用来存放对象的，栈是用来执行程序的。
共享性：堆是线程共享的，栈是线程私有的。
空间大小：堆大小远远大于栈


2.数据类型
基础数据类型中对应的内存空间储存的是具体的值
引用数据类型中对应的内存空间存储的是new对象的地址



3.类加载器
类加载器：就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

双亲委派机制
概念：JVM中是通过类的双亲委派机制来加载的
先使用父加载器加载，如果父加载器找不到要加载的目标类，就使用子加载器自己加载。

类加载器的类
从上到下的父子类加载器，父加载器加载失败，加载子加载器
引导类加载器(BootStrapClassLoader)：负责加载%JAVA_HOME%/jre/lib目录下的所有jar包
扩展类加载器(ExtClassLoader)：负责加载%JAVA_HOME%/jre/lib/ext目录下的所有jar包
应用类加载器(AppClassLoader)：负责加载用户类路径上所指定的类库。
自定义类加载器
这里，需要注意的是：父加载器并不是父类。

为什么要使用，好处（双亲委派机制）
1.我们自己创建一个java.lang.String类，而JDK中也存在一个java.lang.String类
如果我们自己写的类能够随随便便覆盖JDK中的类的话，
那JDK中的代码是不是就没有任何安全性可言了?
没错，JVM为了代码的安全性，也即是沙箱安全机制，使用了双亲委派机制。
2.同时也避免了类的重复加载，因为JVM中区分不同类,不仅仅是根据类名，
相同的class文件被不同的ClassLoader加载就是不同的两个类。

类加载的过程
一个类在JVM中的加载过程大致经历了加载、验证、准备、解析和初始化。
加载： 主要是在计算机磁盘上通过IO流读取字节码文件(.class文件)，
当程序需要使用某个类时，才会对这个类进行加载操作
（验证，准备，解析三步也统称叫做类的链接）
验证：主要的作用就是校验字节码的正确性，是否符合JVM规范。
准备：为类的静态变量分配相应的内存，并赋予默认值。
解析：将程序中的符号引用替换为直接引用，这里的符号引用包括：静态方法等。
初始化：对类的静态变量进行初始化，为其赋予程序中指定的值，并执行静态代码块中的代码。


4.垃圾回收：
优缺点
好处：垃圾收集器通过删除不再引用和使用的对象来自动管理 JVM 内存。
Java 开发人员可以专注于程序逻辑，而不用担心对象删除和内存管理。
缺点：在垃圾收集过程中，应用程序性能可能会受到影响。
在某些称为“停止世界”的情况下，应用程序进程在垃圾收集过程发生时完全停止。
您可以指示 JVM 运行垃圾收集器，但不能保证。
因此，作为开发人员，您不知道垃圾收集过程何时发生。

停止世界（stw）
在垃圾收集过程中，JVM 可能会停止所有应用程序进程线程的执行。这种冻结申请流程被称为“停止世界”
如果没有STW，用户线程将一直执行。

垃圾回收的对象
主要回收的是堆和方法区中的内存
回收对象的基本单位：对于GC中回收的基本单位不是字节而是对象

判定方法
引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为 0 就会回收
引用链法：无法判定相互循环引用（A 引用 B,B 引用 A） 的情况，
通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等-static 变量）来判断，
如果有一条链能够到达 GCROOT 就说明，不能到达 GC ROOT 就说明可以回收。

回收算法
标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，
然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，
新生代基本采用复制算法，老年代采用标记整理算法。
使用场景：1.在配置较好的机器上（比如多核、大内存），
可以为老年代选择并行收集算法： -XX:+UseParallelOldGC 。


jvm参数调优
90%的情况下不用进行参数调优
1.参数
堆栈配置相关
垃圾收集器相关
辅助信息相关

2.如何排查
2.1没有oom
排查思路
可以使⽤jmap来查看JVM中各个区域的使⽤情况；
可以通过jstack来查看线程的运⾏情况，⽐如哪些线程阻塞、是否出现了死锁；
可以通过jstat命令来查看垃圾回收的情况，
特别是fullgc，如果发现fullgc⽐较频繁，那么就得进⾏调优了 ；

调优思路
⾸先，初步猜测频繁发送fullgc的原因，如果频繁发⽣fullgc但是⼜⼀直没有出现内存溢出，
那么表示 fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，
避免这些对 象进⼊到⽼年代，对于这种情况，就要考虑这些存活时间不⻓的对象是不是⽐较大，
导致年轻代放不 下，直接进⼊到了⽼年代，尝试加⼤年轻代的⼤⼩，
如果改完之后，fullgc减少，则证明修改有效；


2.2已经oom
一般⽣产系统中都会设置当系统发⽣了OOM时，⽣成当时的dump⽂件
我们可以利⽤jvisualvm等⼯具来分析dump⽂件（jvisualvm是jdk自带的图形化分析工具，）
根据dump⽂件找到异常的实例对象，和异常的线程（占⽤CPU⾼），定位到具体的代码
堆内存不够用：java.lang.OutOfMemoryError.Java heap space。
栈内存不够用：Java.Lang.StackOverflowError。



jvm参考：
https://blog.csdn.net/weixin_46460843/article/details/119482598
https://www.51cto.com/article/693833.html
https://blog.csdn.net/weixin_69413377/article/details/126194396


jvm排查：
https://blog.csdn.net/weichi7549/article/details/107487962
https://blog.csdn.net/okcross0/article/details/126908176

jvm类的加载
https://blog.csdn.net/weixin_52533007/article/details/123312217
https://blog.csdn.net/petterp/article/details/88757059