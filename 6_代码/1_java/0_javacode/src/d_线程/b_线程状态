

3.线程状态
3.1new 新建状态
使用new关键字和Thread类或者起子类创建一个线程对象后，
该线程对象就处于新建状态。这个状态一直保持程序start()这个线程。

3.2Runnable 就绪状态（可运行状态）
当其他线程调用了该线程对象的start()方法后，该线程就进入就绪状态。
处于就绪状态的线程，随时可能被CPU调度执行。

3.3Running 运行状态
线程获取CPU执行权限进行执行，去执行run()方法，
此时线程处于运行状态，需要注意的是，线程只能从就绪状态进入运行状态。

3.4Blocked 阻塞状态
阻塞状态是线程因为某种原因放弃CPU执行执行资格，暂时停止运行。
知道线程进入就绪状态，才有机会转到运行状态。阻塞状态分为三种情况：
1.等待阻塞：通过调用线程的wait()方法，让线程等带某工作的完成
2.同步阻塞：线程在获取synchronized同步锁失败，它会进入同步阻塞状态
3.其他阻塞：通过调用线程的sleep()或者join()或发出I/O请求时，
线程会进入到阻塞状态。当sleep状态超时、join()等待线程终止或超时、
或I/O处理完毕时，线程重新转入就绪状态。

3.5Dead 死亡状态
线程执行完了或因异常退出了run()方法，该线程结束生命周期。





10.概括的解释下线程的几种可用状态。
1. 新建( new )：新创建了一个线程对象。

2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。
该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。

3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。

4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。
直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：

(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。

(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。

(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，
或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。          
  当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。

5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。



