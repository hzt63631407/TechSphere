
2.接口，抽象类
对比：
1.抽象类和接口都不能够实例化、不能有构造方法
2.类能实现一个或多个接口，但只能继承一个抽象类
3.子类使用extends关键字来继承抽象类，子类使用关键字implements来实现接口。
4.接口只有定义，不能有方法的实现，
而抽象类可以有定义与实现，即其方法可以在抽象类中被实现。

抽象类
1.抽象类可以有构造方法
2.用抽象类是为了重用。减少编码量，降低耦合性。

接口
1.接口用interface来修饰
2.接口中声明全是public static final修饰的常量
3.接口中所有方法都是抽象方法
4.接口是没有构造方法的

List list = new  ArrayList()
List是接口，ArrayList是它的实现类
https://blog.csdn.net/cristianoxm/article/details/106354344
好处
1.在设计模式中有对依赖倒置原则,程序要尽量依赖于抽象，不依赖于具体。
2.提高程序宽展性,以后修改维护好些
问题就在于List有多个实现类，如 LinkedList或者Vector等等，
现在你用的是ArrayList，也许哪一天你需要换成其它的实现类呢？
这时你只要改变这一行就行了：List list = new LinkedList();
其它使用了list地方的代码根本不需要改动。
假设你开始用 ArrayList alist = new ArrayList(),
这下你有的改了，特别是如果你使用了 ArrayList特有的方法和属性。




6.接口和抽象类的区别是什么？
Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。
也可以参考JDK8中抽象类和接口的区别




接口 interface

使用interface声明一个接口，接口只有抽象方法

实现interface使用implements

一个class可以实现多个interface

接口：

不能定义实例字段
不能定义普通方法
可以定义default方法（default方法子类可以不实现 JDK>=1.8）
一个接口可以extends另一个接口，相当于扩展接口方法

接口层次代表抽象程度

接口也是数据类型，适用于向上转型和向下转型



接口的静态字段

因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，

并且静态字段必须为final类型：（自己：如果任何一个子类修改，全部都改）

public interface Person {
    public static final int MALE = 1;
    public static final int FEMALE = 2;
}
实际上，因为interface的字段只能是public static final类型，
所以我们可以把这些修饰符都去掉，上述代码可以简写为：

public interface Person {
    // 编译器会自动加上public statc final:
    int MALE = 1;
    int FEMALE = 2;
}
编译器会自动把该字段变为public static final类型。


一、为什么要用final？

　　首先，我们应该明白一个问题。接口，实际上比抽象类更加抽象，它是最高层次的抽象。

接口中的所有方法都是抽象方法，不会有任何实现方面的代码，而它的具体实现是要靠实现这个接口的具体类来具体实现的。

而且，这个接口中的方法是不可更改的。

同样的，接口中的变量也是不可更改的。所以，要声明为final。

接口是一种协议，协议是所有实现接口的类都必须遵守的。如果变量不是final，
那么每个实现接口的类就可以更改这个变量的值，也就违反了OCP原则。




二、为什么要用static？

　　至于这个问题，是和Java语言的本身机制有关。我们知道Java不支持多继承，但是一个类可是现实多个接口。

我们假设有两个接口A和B，而类C实现了接口A和B。假设，此时，A和B中都有一个变量N，如果N不是static类型的，

那么在C中该如何区分N到底是A的还是B的呢？

而，如果是static类型的，我们可以通过A.N和B.N来区别调用A或者B中的成员变量N。







