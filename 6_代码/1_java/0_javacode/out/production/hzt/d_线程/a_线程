

wait和sleep的区别
1.sleep()是属于Thread类，wait()是属于Object类
2.sleep()不依赖同步方法，而wait()依赖，
并且sleep()不会释放锁，wait会释放锁
3.sleep()不需要唤醒 超时结束就会进入就绪状态，
wait需要notify()或者notifyAll()唤醒



1.线程启动
在Java中，每次程序运行至少启动2个线程：
一个是main线程，一个是垃圾收集线程。
因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，
每一个JVM实际上就是在操作系统中启动了一个进程。



2.线程创建
2.1继承Thread类（假设子类为MyThread），并重写run()方法，
然后new一个MyThread对象并对其调用start()即可启动新线程。

2.2实现Runnable接口（假设实现类为MyRunnable），
而后将MyRunnable对象作为参数传入Thread构造器，
在得到的Thread对象上调用start()方法即可。



3.线程状态
3.1new 新建状态
使用new关键字和Thread类或者起子类创建一个线程对象后，
该线程对象就处于新建状态。这个状态一直保持程序start()这个线程。

3.2Runnable 就绪状态（可运行状态）
当其他线程调用了该线程对象的start()方法后，该线程就进入就绪状态。
处于就绪状态的线程，随时可能被CPU调度执行。

3.3Running 运行状态
线程获取CPU执行权限进行执行，去执行run()方法，
此时线程处于运行状态，需要注意的是，线程只能从就绪状态进入运行状态。

3.4Blocked 阻塞状态
阻塞状态是线程因为某种原因放弃CPU执行执行资格，暂时停止运行。
知道线程进入就绪状态，才有机会转到运行状态。阻塞状态分为三种情况：
1.等待阻塞：通过调用线程的wait()方法，让线程等带某工作的完成
2.同步阻塞：线程在获取synchronized同步锁失败，它会进入同步阻塞状态
3.其他阻塞：通过调用线程的sleep()或者join()或发出I/O请求时，
线程会进入到阻塞状态。当sleep状态超时、join()等待线程终止或超时、
或I/O处理完毕时，线程重新转入就绪状态。

3.5Dead 死亡状态
线程执行完了或因异常退出了run()方法，该线程结束生命周期。






4.线程方法
4.1start方法
线程创建以后，并不会自动运行，需要我们手动的start，将线程的状态设为就绪状态

4.2join方法（停止当前）
join方法，意思就是在自己当前线程加入你调用的线程，本线程则等待
如果在t1线程里面调用了t2.join()，则t1线程会进行等待状态.

4.3wait()
是使当前线程阻塞，前提是必须先获得锁，一般配合到synchronized来使用

4.4notify/notifyAll() 被执行时候，
才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行



5.线程同步
5.1为什么需要线程同步
当使用多个线程来访问同一个数据时，
将会导致数据不准确，相互之间产生冲突，非常容易出现线程安全问题

5.2如何进行线程同步
1.使用synchronized关键字
由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法
通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

2.使用ReentrantLock
它与使用synchronized方法具有相同的基本行为和语义，并且扩展了其能力。
使用 ReentrantLock锁，JVM 将花费较少的时间来调度线程，
线程更好,并且具有更好的扩展性

3.使用volatile
volatile关键字为域变量的访问提供了一种免锁机制

4.原子变量
在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，
使用该类可以简化线程同步



6.锁
死锁就是指两个或两个以上的线程在执行过程中，
由于竞争资源或者由于彼此通信而造成的现象，若无外力作用



7.多线程的好处
7.1能够更充分地利用cpu。大多数的计算机只有一个cpu，
所以能够充分运用cpu资源就显得格外重要，在单线程中，
总有部分cpu处于空闲状态，如果使用java多线程则能够保持cpu的高速运转状态，
不会有某部分空闲下来。

7.2简化编程的步骤。假如说程序只需要进行单一的项目，
那么直接使用单线程即可，如果要完成多个项目，
使用单线程则不大合适，java多线程能够同时处理多个任务，
简化编程的步骤，减少等待的时间。







9.创建线程有几种不同的方式？你喜欢哪一种？为什么？
1，继承Thread类，重写run方法；
2，实现Runnable接口，重写run方法，但是比继承Thread类好用，
实现接口还可以继承类，避免了单继承带来的局限性；
3，实现callable接口，重写call方法，有返回值。
4，使用实现了Execu
tor接口的ThreadPoolExecutor来创建线程池。

10.概括的解释下线程的几种可用状态。
1. 新建( new )：新创建了一个线程对象。
2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。
3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。
4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：
(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。
(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。
(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。
5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。






11.同步方法和同步代码块的区别是什么？
查看最后整理thread部分


12.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？
在 java 虚拟机中, 每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联, 为了实现监视器的互斥功能, 每个对象都关联着一把锁.
 
一旦方法或者代码块被 synchronized 修饰, 那么这个部分就放入了监视器的监视区域, 确保一次只能有一个线程执行该部分的代码, 线程在获取锁之前不允许执行该部分的代码
 
另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案

13.什么是死锁(deadlock)？
所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：
互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。

14.如何确保N个线程可以访问N个资源同时又不导致死锁？
多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。




8.进程和线程的区别是什么？
进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
线程与进程的区别归纳：
a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
c.调度和切换：线程上下文切换比进程上下文切换要快得多。
d.在多线程OS中，进程不是一个可执行的实体。
