可以将 ArrayList想象成一种“会自动扩增容量的Array”。

Array（[]）：最高效；但是其容量固定且无法动态改变；
ArrayList：  容量可动态增长；但牺牲效率；

建议：
基于效率和类型检验，应尽可能使用Array，无法确定数组大小时才使用ArrayList！
不过当你试着解决更一般化的问题时，Array的功能就可能过于受限。

array可以放对象


实际上ArrayList内部就是一个Object[]数组，配合存储一个当前分配的长度，就可以充当“可变数组”：

为了解决新的问题，我们必须把ArrayList变成一种模板：ArrayList<T>，代码如下：

T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList：

因为Java引入了泛型，所以，只用Class来标识类型已经不够了。实际上，Java的类型系统结构如下：

                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘



这样一来，给方法传入Pair<Integer>类型时，它符合参数Pair<? extends Number>类型。

这种使用<? extends Number>的泛型定义称之为上界通配符（Upper Bounds Wildcards），
即把泛型类型T的上界限定在Number了。

除了可以传入Pair<Integer>类型，我们还可以传入Pair<Double>类型，Pair<BigDecimal>类型等等，
因为Double和BigDecimal都是Number的子类。

例如下面这个两个方法表达的意思是一样的，都表示参数是一个集合，这个集合可能包含着A或者A的任何子类


public void someMethod(List<? extends A> list);

这是一种情况，但是相比而言，一个类中，多处方法都需要这个泛型的时候，
<T extends A>要比<? extends A> 方便的多，就像在代码里，
你声明了一个变量后，你就可以在这个变量的代码块里任何地方调用，
同理<T extends A>就像是声明了一个泛型变量T，这个T是一个A或者A的子类，
然后这个变量T在所能用的范围之内，
你都可以直接用T表示，不用再写<? extends A>或者<T extends A>，比如：


// 前面定义了T，后面参数就可以用T表示了
public <T extends A>void some(List<T> t);
上面是方法里，这个范围比较窄，放在类里，效果更明显，比如：


public class B<T extends A>{
    // 一个A类或者A子类的变量
    private T a;
     
    // 一个方法
    public void some(List<T> list);
}