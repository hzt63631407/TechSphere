
1.数据类型哪些是可变的
不可变对象，该对象所指向的内存中的值不能被改变。
可变对象，该对象所指向的内存中的值可以被改变。
数值类型（int和float）、字符串str、元组tuple都是不可变类型。
而列表list、字典dict、集合set是可变类型。

不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，
而对于相同的值的对象，在内存中则只有一个对象（一个地址），
如下图用id()方法可以打印对象的内存id。

允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，
只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化

可变类型：list、dict、set(可以进行增删，list.append，list.remove)
不可变类型：number、str、bool、tuple、float
python中的不可变数据类型，不允许变量的值 原地 发生变化，
一但值发生了变化，则相当于新建了一个对象，id会变。


2.什么是字典
字典就是可变的数据结构，存储键值对
且可存储任意类型对象，比如字符串、数字、列表等
key是唯一的，是不可以变类型。
大多数Python对象可以作为键，但它们必须是可哈希的对象。
像列表和字典这样的可变类型，由于它们不是可哈希的，所以不能作答为键。


3.==和is的区别是？
==比较两个对象或值的相等性。
is运算符用于检查两个对象是否属于同一内存对象。



4.浅拷贝和深拷贝
（内存地址，指针，引用是同一个概念）
浅拷贝：浅拷贝是拷贝对象的引用，所以拷贝出来的对象内存地址是相同的。
如果你改变了其中一个的值，那么另外一个也改变。
深拷贝：深拷贝是一个出了新的对象，拷贝后是新的对象，内存地址是不同的。
如果你改变了其中一个的值，那么一个不会改变。

我们可以改变可变类型中包含的值，
但内存地址不变，所以值也会跟着改变，因为指向同一个地方。
比如说 list = [1]  l = [2]
如果是深拷贝，那么改变其中的一个，另一个是不会跟着变得。


对于可变类型，浅拷贝就变化了一个改变就改变，如果深拷贝，一个变化另一个不会变。
不可变类型，不管是深拷贝还是浅拷贝，改变之后，因为内存地址都改变，所以都会变化。
a = 3, a = 4


浅拷贝(copy)，深拷贝(deepcopy)



5.参数如何通过值或引用传递
a = 3.14 b = 3.14 a = b
只向同一个引用
Python中的所有内容都是一个对象，所有变量都包含对象的引用。


6.同一时间内只有一个线程在运行，cpu最多到100%
GIL是Python的全局解释器锁，同一进程中假如有多个线程运行，
一个线程在运行Python程序的时候会霸占Python解释器（加了一把锁即GIL），
使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。
如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。
所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。

当然，CPython 会做一些小把戏，轮流执行 Python 线程。
这样一来，用户看到的就是“伪并行”——Python 线程在交错执行，来模拟真正并行的线程。

所以即使再多的线程也只能有效的使用一个 CPU。
由于 GIL 的存在，即便是多线程的 Python 程序也无法利用多核 CPU 的优势。
不过 I/O 密集型程序，依然适合使用多线程，
因为它们大部分时间都在等待 I/O，对 CPU 依赖很低。
（puyhon是io型程序，c，java是算法型）



7.Python是如何进行内存管理的
一垃圾回收机制，对象的引用计数机制
二内存池机制

一、垃圾回收
1.引用计数为主 当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
2.标记清除为辅 循环引用发生在至少有两个对象互相作用，垃圾回收器也会清理为引用的循环
3.分代收集  在执行垃圾回收过程中，程序会被暂停，即stop-the-world。
这里很好理解：你妈妈在打扫房间的时候，肯定不允许你在房间内到处丢垃圾，要不然永远也无法打扫干净。

分代回收基于这样的法则：
接大部分的对象生命周期短，大部分对象都是朝生夕灭。
经历越多次数的垃圾收集且活下来的对象，说明该对象越不可能是垃圾，应该越少去收集。

Python中，对象一共有3种世代：G0,G1,G2。
对象刚创建时为G0。
如果在一轮GC扫描中存活下来，则移至G1，处于G1的对象被扫描次数会减少。
如果再次在扫描中活下来，则进入G2，处于G1的对象被扫描次数将会更少。


对象的引用计数机制
Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。
引用计数增加的情况：
1.对象被创建，如A()。
2.对象被引用，如a=A()。
3.对象作为函数的参数，如func(a)。
4.对象作为容器的元素，如arr=[a,a]。
引用计数减少的情况：
1.对象被显式销毁，如del方法 a。
2.变量重新赋予新的对象，例如a=0。
3.对象离开它的作用域，如func函数执行完毕时，func函数中的局部变量（全局变量不会）。
4.窗口对象本身被销毁



二、内存池机制
Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，
用于管理对小块内存的申请和释放。
2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，
而大的对象则使用系统的malloc。
3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，
对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，
用于缓存这些整数的内存就不能再分配给浮点数


当退出 Python 时是否释放所有内存分配？
答案是否定的。那些具有对象循环引用或者全局命名空间引用的变量，
在 Python 退出是往往不会被释放。



__del__语句
https://www.cnblogs.com/wrnmmdwa/p/15656715.html

在python中，垃圾回收算法以引用计数为主
https://cloud.tencent.com/developer/article/2045561