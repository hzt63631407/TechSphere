python相关
1.装饰器
它主要用于解决想要在原有函数或类的基础上进行功能扩展，
但又不会破坏这个函数本身的功能。
并且我们可以方便的添加和去除这一部分扩展的功能的需求。

python装饰器有很多经典的应用场景，
比如：插入日志、性能测试、事务处理、权限校验等。
定义一个日志函数，可以打印出日志

平时使用
用例重试@retry函数
（还有就是log函数）

Python中的装饰器的原理：
是通过利用了函数特性实现，有以下几个特点
1.函数可以当作参数
2.函数可以当作返回
3.跨域访问，引用了外部变量x
https://www.cnblogs.com/luxiangyu111/p/9671395.html

log(func())

什么时候使用：函数可以作为参数传递的语言，可以使用装饰器。
靠近原函数的先进行装饰后执行，离原函数远的后装饰先执行。

装饰器传参数，再包一层，因为装饰器本身也是一个函数，如果要传参数，
定义一个函数来接受函数。


什么是闭包
当我们在外部函数中定义了一个内部函数，
并且内部函数能够读取到外部函数内的变量，这种函数我们就称为闭包。

def demo(x,y):
	def add():
		return x+y
	return add



2.python requests
r = requests.get("http://httpbin.org/get", params=payload)
r.text 文本响应内容
r.status_code


3.unittest：
原理：
首先我们需要创建测试用例，然后利用加载器讲用例加载到测试套件中，
并创建一个执行器,去执行测试条件中的所有用例

单元测试框架，你写一个函数，是用test开头，再把这个函数加到unittest里面去。
TestCase：测试用例，测试用例里面会有很多测试方法，是单元测试中最小维度的测试行为
TestSuite：测试套件,是测试用例的集合
TestRunner：测试运行器，运行测试用例
TestReport：将测试结果呈现给用户，生成测试报告

https://blog.csdn.net/u012878945/article/details/102769465
https://blog.csdn.net/weixin_45271990/article/details/118087591

https://zhuanlan.zhihu.com/p/87775743
fixture有点类似（setup/teardown）
（每个函数、模块之前运行）
可以设置成函数、模块、类或整个项目中的使用来激活
关于autouse，默认是False。
（应用场景：每次class之前检查是否登陆）


pytest和unntest类似，都是test函数开头，
都有setup/teardown这些前置或者后置方法
也有断言，也能生成html的报告，pytest有自己的用例重试。


pytest可以支持分布式，即多线程，可以是单机，也可以多台机器
https://www.cnblogs.com/QianyuQian/p/16784295.html


4.python 常用的库
os：提供了不少与操作系统相关联的函数
sys：通常用于命令行参数
re：正则匹配
math：数学运算
datetime：处理日期时间
repuqst:网络请求


5.区分Python中的remove，del和pop？
remove：将删除列表中的第一个匹配值，它以值作为参数。
del：使用索引删除元素，它不返回任何值。
pop：将删除列表中顶部的元素，并返回列表的顶部元素。


6.报错
python的没有excption一说，excption是一个大类，里面有很多error，如下：
1.indexerror
2.MemoryError
3.TypeError
4.ModuleNotFoundError
5.ioFoundError
6.NameError
（raise引发异常）


7.面向对象
封装，继承，多态
封装：就是把客观的事物封装成抽象类，类具有属性和功能，功能就是方法
继承：子类有用父类的方法
多态：不同的子类调用相同的方法，产生不同的结果。
有一个父类，有一个函数，不同的子类在调用的时候会产生不同的结果。


8.设计模式
1.单例 只能创建一个实例使用装饰器实现单例模式。
需要频繁创建和销毁的对象；
场景限定只需要创建一个;
1.1基于__new__方法实现单例模式
class Singleton(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls,'_instance'):
            orig=super(Singleton,cls)
            cls._instance=orig.__new__(cls,*args,**kwargs)
        return cls._instance

class MyClass(Singleton):
    a=1
one=MyClass()
two=MyClass()
1.2.基于装饰器实现单例模式，@singleTon
2.工厂 一个方法，有一个参数，根据这个参数的类的不同执行不同的方法。


9.IO流
读跟写（读：从磁盘读到内存，写，从内存写到磁盘）
with open 如果有I0流报错，f.close(),保存。
为了保证无论是否出错都能正确地关闭文件。
r：read表示输入流
w：write表示输出流

with open('foo.txt', 'w') as f:
    f.write("hello")                    # 不管原来是什么，都会弃掉，重新写。

with open('foo.txt', 'rb') as f:
    print(f.read())













